// Code generated by goa v3.3.1, DO NOT EDIT.
//
// log HTTP client CLI support package
//
// Command:
// $ goa gen github.com/NeedMoreVolume/FireTracker/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	log "github.com/NeedMoreVolume/FireTracker/gen/log"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreatePayload builds the payload for the log create endpoint from CLI
// flags.
func BuildCreatePayload(logCreateBody string) (*log.Log, error) {
	var err error
	var body CreateRequestBody
	{
		err = json.Unmarshal([]byte(logCreateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"id\": 3719654112391162300,\n      \"name\": \"Big Log\",\n      \"size\": \"M\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Sunny\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
		}
	}
	v := &log.Log{
		ID:        body.ID,
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
		Name:      body.Name,
		Size:      body.Size,
		FireID:    body.FireID,
		AddedAt:   body.AddedAt,
	}
	if body.Weather != nil {
		v.Weather = marshalWeatherRequestBodyToLogWeather(body.Weather)
	}

	return v, nil
}

// BuildGetPayload builds the payload for the log get endpoint from CLI flags.
func BuildGetPayload(logGetBody string, logGetID string) (*log.Log, error) {
	var err error
	var body GetRequestBody
	{
		err = json.Unmarshal([]byte(logGetBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"name\": \"Big Log\",\n      \"size\": \"L\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Sunny\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
		}
	}
	var id int
	{
		var v int64
		v, err = strconv.ParseInt(logGetID, 10, 64)
		id = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT")
		}
	}
	v := &log.Log{
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
		Name:      body.Name,
		Size:      body.Size,
		FireID:    body.FireID,
		AddedAt:   body.AddedAt,
	}
	if body.Weather != nil {
		v.Weather = marshalWeatherRequestBodyToLogWeather(body.Weather)
	}
	v.ID = &id

	return v, nil
}

// BuildUpdatePayload builds the payload for the log update endpoint from CLI
// flags.
func BuildUpdatePayload(logUpdateBody string, logUpdateID string) (*log.Log, error) {
	var err error
	var body UpdateRequestBody
	{
		err = json.Unmarshal([]byte(logUpdateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"name\": \"Big Log\",\n      \"size\": \"L\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Sunny\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
		}
	}
	var id int
	{
		var v int64
		v, err = strconv.ParseInt(logUpdateID, 10, 64)
		id = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT")
		}
	}
	v := &log.Log{
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
		Name:      body.Name,
		Size:      body.Size,
		FireID:    body.FireID,
		AddedAt:   body.AddedAt,
	}
	if body.Weather != nil {
		v.Weather = marshalWeatherRequestBodyToLogWeather(body.Weather)
	}
	v.ID = &id

	return v, nil
}

// BuildDeletePayload builds the payload for the log delete endpoint from CLI
// flags.
func BuildDeletePayload(logDeleteBody string, logDeleteID string) (*log.Log, error) {
	var err error
	var body DeleteRequestBody
	{
		err = json.Unmarshal([]byte(logDeleteBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"name\": \"Big Log\",\n      \"size\": \"M\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"K\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Sunny\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
		}
	}
	var id int
	{
		var v int64
		v, err = strconv.ParseInt(logDeleteID, 10, 64)
		id = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT")
		}
	}
	v := &log.Log{
		CreatedAt: body.CreatedAt,
		UpdatedAt: body.UpdatedAt,
		Name:      body.Name,
		Size:      body.Size,
		FireID:    body.FireID,
		AddedAt:   body.AddedAt,
	}
	if body.Weather != nil {
		v.Weather = marshalWeatherRequestBodyToLogWeather(body.Weather)
	}
	v.ID = &id

	return v, nil
}

// BuildListPayload builds the payload for the log list endpoint from CLI flags.
func BuildListPayload(logListBody string) (*log.LogListPayload, error) {
	var err error
	var body ListRequestBody
	{
		err = json.Unmarshal([]byte(logListBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filters\": {\n         \"end\": [\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"=\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"=\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"=\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            }\n         ],\n         \"name\": [\n            {\n               \"key\": \"name\",\n               \"operator\": \"=\",\n               \"value\": \"Daniel\"\n            },\n            {\n               \"key\": \"name\",\n               \"operator\": \"=\",\n               \"value\": \"Daniel\"\n            }\n         ],\n         \"start\": [\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"=\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"=\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            }\n         ]\n      },\n      \"pagination\": {\n         \"limit\": 10,\n         \"page\": 1\n      },\n      \"search\": {\n         \"description\": \"Like a cheese wheel\",\n         \"name\": \"Big Log\"\n      },\n      \"sort\": {\n         \"end\": \"ASC, DESC\",\n         \"id\": \"ASC, DESC\",\n         \"start\": \"ASC, DESC\"\n      }\n   }'")
		}
		if body.Filters == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("filters", "body"))
		}
		if body.Search == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("search", "body"))
		}
		if body.Sort == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("sort", "body"))
		}
		if body.Pagination == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("pagination", "body"))
		}
		if body.Filters != nil {
			if err2 := ValidateLogFiltersRequestBody(body.Filters); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if body.Sort != nil {
			if err2 := ValidateLogSortsRequestBody(body.Sort); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &log.LogListPayload{}
	if body.Filters != nil {
		v.Filters = marshalLogFiltersRequestBodyToLogLogFilters(body.Filters)
	}
	if body.Search != nil {
		v.Search = marshalLogSearchRequestBodyToLogLogSearch(body.Search)
	}
	if body.Sort != nil {
		v.Sort = marshalLogSortsRequestBodyToLogLogSorts(body.Sort)
	}
	if body.Pagination != nil {
		v.Pagination = marshalLogPaginationRequestBodyToLogLogPagination(body.Pagination)
	}

	return v, nil
}
