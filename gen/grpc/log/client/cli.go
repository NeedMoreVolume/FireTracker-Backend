// Code generated by goa v3.3.1, DO NOT EDIT.
//
// log gRPC client CLI support package
//
// Command:
// $ goa gen github.com/NeedMoreVolume/FireTracker/design

package client

import (
	"encoding/json"
	"fmt"

	logpb "github.com/NeedMoreVolume/FireTracker/gen/grpc/log/pb"
	log "github.com/NeedMoreVolume/FireTracker/gen/log"
)

// BuildCreatePayload builds the payload for the log create endpoint from CLI
// flags.
func BuildCreatePayload(logCreateMessage string) (*log.Log, error) {
	var err error
	var message logpb.CreateRequest
	{
		if logCreateMessage != "" {
			err = json.Unmarshal([]byte(logCreateMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"id\": 2504154618982890109,\n      \"name\": \"Big Log\",\n      \"size\": \"M\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Raining\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
			}
		}
	}
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}

	return v, nil
}

// BuildGetPayload builds the payload for the log get endpoint from CLI flags.
func BuildGetPayload(logGetMessage string) (*log.Log, error) {
	var err error
	var message logpb.GetRequest
	{
		if logGetMessage != "" {
			err = json.Unmarshal([]byte(logGetMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"id\": 4851642269298561001,\n      \"name\": \"Big Log\",\n      \"size\": \"M\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Raining\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
			}
		}
	}
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}

	return v, nil
}

// BuildUpdatePayload builds the payload for the log update endpoint from CLI
// flags.
func BuildUpdatePayload(logUpdateMessage string) (*log.Log, error) {
	var err error
	var message logpb.UpdateRequest
	{
		if logUpdateMessage != "" {
			err = json.Unmarshal([]byte(logUpdateMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"id\": 9080228146750712829,\n      \"name\": \"Big Log\",\n      \"size\": \"M\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Raining\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
			}
		}
	}
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}

	return v, nil
}

// BuildDeletePayload builds the payload for the log delete endpoint from CLI
// flags.
func BuildDeletePayload(logDeleteMessage string) (*log.Log, error) {
	var err error
	var message logpb.DeleteRequest
	{
		if logDeleteMessage != "" {
			err = json.Unmarshal([]byte(logDeleteMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"addedAt\": \"2020-01-02T00:00:00Z\",\n      \"createdAt\": \"2020-01-02T00:00:00Z\",\n      \"fireID\": 1,\n      \"id\": 1826054546400423160,\n      \"name\": \"Big Log\",\n      \"size\": \"XL\",\n      \"updatedAt\": \"2020-01-02T00:00:00Z\",\n      \"weather\": {\n         \"createdAt\": \"2020-01-02T00:00:00Z\",\n         \"dewPoint\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"fireID\": 1,\n         \"humidity\": 1500,\n         \"id\": 1,\n         \"logID\": 1,\n         \"temperature\": {\n            \"unit\": \"C\",\n            \"value\": 20\n         },\n         \"weatherTime\": \"2020-01-02T00:00:00Z\",\n         \"weatherType\": \"Raining\",\n         \"wind\": {\n            \"direction\": \"SE\",\n            \"speed\": 15,\n            \"unit\": \"KPH\"\n         }\n      }\n   }'")
			}
		}
	}
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}

	return v, nil
}

// BuildListPayload builds the payload for the log list endpoint from CLI flags.
func BuildListPayload(logListMessage string) (*log.LogListPayload, error) {
	var err error
	var message logpb.ListRequest
	{
		if logListMessage != "" {
			err = json.Unmarshal([]byte(logListMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filters\": {\n         \"end\": [\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"\\u003c\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"\\u003c\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"\\u003c\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"\\u003c\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            }\n         ],\n         \"name\": [\n            {\n               \"key\": \"name\",\n               \"operator\": \"!=\",\n               \"value\": \"Daniel\"\n            },\n            {\n               \"key\": \"name\",\n               \"operator\": \"!=\",\n               \"value\": \"Daniel\"\n            }\n         ],\n         \"start\": [\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"\\u003c\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"\\u003c\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            },\n            {\n               \"key\": \"added_at\",\n               \"operator\": \"\\u003c\",\n               \"value\": \"2020-01-01T00:00:00Z\"\n            }\n         ]\n      },\n      \"pagination\": {\n         \"limit\": 10,\n         \"page\": 1\n      },\n      \"search\": {\n         \"description\": \"Like a cheese wheel\",\n         \"name\": \"Big Log\"\n      },\n      \"sort\": {\n         \"end\": \"ASC, DESC\",\n         \"id\": \"ASC, DESC\",\n         \"start\": \"ASC, DESC\"\n      }\n   }'")
			}
		}
	}
	v := &log.LogListPayload{}
	if message.Filters != nil {
		v.Filters = protobufLogpbLogFiltersToLogLogFilters(message.Filters)
	}
	if message.Search != nil {
		v.Search = protobufLogpbLogSearchToLogLogSearch(message.Search)
	}
	if message.Sort != nil {
		v.Sort = protobufLogpbLogSortsToLogLogSorts(message.Sort)
	}
	if message.Pagination != nil {
		v.Pagination = protobufLogpbLogPaginationToLogLogPagination(message.Pagination)
	}

	return v, nil
}
