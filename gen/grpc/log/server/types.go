// Code generated by goa v3.2.5, DO NOT EDIT.
//
// log gRPC server types
//
// Command:
// $ goa gen github.com/NeedMoreVolume/FireTracker/design

package server

import (
	logpb "github.com/NeedMoreVolume/FireTracker/gen/grpc/log/pb"
	log "github.com/NeedMoreVolume/FireTracker/gen/log"
	goa "goa.design/goa/v3/pkg"
)

// NewCreatePayload builds the payload of the "create" endpoint of the "log"
// service from the gRPC request type.
func NewCreatePayload(message *logpb.CreateRequest) *log.Log {
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}
	return v
}

// NewCreateResponse builds the gRPC response type from the result of the
// "create" endpoint of the "log" service.
func NewCreateResponse(result *log.Log) *logpb.CreateResponse {
	message := &logpb.CreateResponse{}
	if result.ID != nil {
		message.Id = int32(*result.ID)
	}
	if result.CreatedAt != nil {
		message.CreatedAt = *result.CreatedAt
	}
	if result.UpdatedAt != nil {
		message.UpdatedAt = *result.UpdatedAt
	}
	if result.Name != nil {
		message.Name = *result.Name
	}
	if result.Size != nil {
		message.Size = *result.Size
	}
	if result.FireID != nil {
		message.FireId = int32(*result.FireID)
	}
	if result.AddedAt != nil {
		message.AddedAt = *result.AddedAt
	}
	if result.Weather != nil {
		message.Weather = svcLogWeatherToLogpbWeather(result.Weather)
	}
	return message
}

// NewGetPayload builds the payload of the "get" endpoint of the "log" service
// from the gRPC request type.
func NewGetPayload(message *logpb.GetRequest) *log.Log {
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}
	return v
}

// NewGetResponse builds the gRPC response type from the result of the "get"
// endpoint of the "log" service.
func NewGetResponse(result *log.Log) *logpb.GetResponse {
	message := &logpb.GetResponse{}
	if result.ID != nil {
		message.Id = int32(*result.ID)
	}
	if result.CreatedAt != nil {
		message.CreatedAt = *result.CreatedAt
	}
	if result.UpdatedAt != nil {
		message.UpdatedAt = *result.UpdatedAt
	}
	if result.Name != nil {
		message.Name = *result.Name
	}
	if result.Size != nil {
		message.Size = *result.Size
	}
	if result.FireID != nil {
		message.FireId = int32(*result.FireID)
	}
	if result.AddedAt != nil {
		message.AddedAt = *result.AddedAt
	}
	if result.Weather != nil {
		message.Weather = svcLogWeatherToLogpbWeather(result.Weather)
	}
	return message
}

// NewUpdatePayload builds the payload of the "update" endpoint of the "log"
// service from the gRPC request type.
func NewUpdatePayload(message *logpb.UpdateRequest) *log.Log {
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}
	return v
}

// NewUpdateResponse builds the gRPC response type from the result of the
// "update" endpoint of the "log" service.
func NewUpdateResponse(result *log.Log) *logpb.UpdateResponse {
	message := &logpb.UpdateResponse{}
	if result.ID != nil {
		message.Id = int32(*result.ID)
	}
	if result.CreatedAt != nil {
		message.CreatedAt = *result.CreatedAt
	}
	if result.UpdatedAt != nil {
		message.UpdatedAt = *result.UpdatedAt
	}
	if result.Name != nil {
		message.Name = *result.Name
	}
	if result.Size != nil {
		message.Size = *result.Size
	}
	if result.FireID != nil {
		message.FireId = int32(*result.FireID)
	}
	if result.AddedAt != nil {
		message.AddedAt = *result.AddedAt
	}
	if result.Weather != nil {
		message.Weather = svcLogWeatherToLogpbWeather(result.Weather)
	}
	return message
}

// NewDeletePayload builds the payload of the "delete" endpoint of the "log"
// service from the gRPC request type.
func NewDeletePayload(message *logpb.DeleteRequest) *log.Log {
	v := &log.Log{}
	if message.Id != 0 {
		idptr := int(message.Id)
		v.ID = &idptr
	}
	if message.CreatedAt != "" {
		v.CreatedAt = &message.CreatedAt
	}
	if message.UpdatedAt != "" {
		v.UpdatedAt = &message.UpdatedAt
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.Size != "" {
		v.Size = &message.Size
	}
	if message.FireId != 0 {
		fireIDptr := int(message.FireId)
		v.FireID = &fireIDptr
	}
	if message.AddedAt != "" {
		v.AddedAt = &message.AddedAt
	}
	if message.Weather != nil {
		v.Weather = protobufLogpbWeatherToLogWeather(message.Weather)
	}
	return v
}

// NewDeleteResponse builds the gRPC response type from the result of the
// "delete" endpoint of the "log" service.
func NewDeleteResponse() *logpb.DeleteResponse {
	message := &logpb.DeleteResponse{}
	return message
}

// NewListPayload builds the payload of the "list" endpoint of the "log"
// service from the gRPC request type.
func NewListPayload(message *logpb.ListRequest) *log.LogListPayload {
	v := &log.LogListPayload{}
	if message.Filters != nil {
		v.Filters = protobufLogpbLogFiltersToLogLogFilters(message.Filters)
	}
	if message.Search != nil {
		v.Search = protobufLogpbLogSearchToLogLogSearch(message.Search)
	}
	if message.Sort != nil {
		v.Sort = protobufLogpbLogSortsToLogLogSorts(message.Sort)
	}
	if message.Pagination != nil {
		v.Pagination = protobufLogpbLogPaginationToLogLogPagination(message.Pagination)
	}
	return v
}

// NewListResponse builds the gRPC response type from the result of the "list"
// endpoint of the "log" service.
func NewListResponse(result *log.LogList) *logpb.ListResponse {
	message := &logpb.ListResponse{}
	if result.Logs != nil {
		message.Logs = make([]*logpb.Log2, len(result.Logs))
		for i, val := range result.Logs {
			message.Logs[i] = &logpb.Log2{}
			if val.ID != nil {
				message.Logs[i].Id = int32(*val.ID)
			}
			if val.CreatedAt != nil {
				message.Logs[i].CreatedAt = *val.CreatedAt
			}
			if val.UpdatedAt != nil {
				message.Logs[i].UpdatedAt = *val.UpdatedAt
			}
			if val.Name != nil {
				message.Logs[i].Name = *val.Name
			}
			if val.Size != nil {
				message.Logs[i].Size = *val.Size
			}
			if val.FireID != nil {
				message.Logs[i].FireId = int32(*val.FireID)
			}
			if val.AddedAt != nil {
				message.Logs[i].AddedAt = *val.AddedAt
			}
			if val.Weather != nil {
				message.Logs[i].Weather = svcLogWeatherToLogpbWeather(val.Weather)
			}
		}
	}
	if result.Pagination != nil {
		message.Pagination = svcLogPaginationToLogpbPagination(result.Pagination)
	}
	return message
}

// ValidateCreateRequest runs the validations defined on CreateRequest.
func ValidateCreateRequest(message *logpb.CreateRequest) (err error) {
	if message.CreatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.createdAt", message.CreatedAt, goa.FormatDateTime))
	}
	if message.UpdatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.updatedAt", message.UpdatedAt, goa.FormatDateTime))
	}
	if message.Size != "" {
		if !(message.Size == "S" || message.Size == "M" || message.Size == "L" || message.Size == "XL") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.size", message.Size, []interface{}{"S", "M", "L", "XL"}))
		}
	}
	if message.AddedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.addedAt", message.AddedAt, goa.FormatDateTime))
	}
	if message.Weather != nil {
		if err2 := ValidateWeather(message.Weather); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateWeather runs the validations defined on Weather.
func ValidateWeather(message *logpb.Weather) (err error) {
	if message.CreatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.createdAt", message.CreatedAt, goa.FormatDateTime))
	}
	if message.Temperature != nil {
		if err2 := ValidateTemperature(message.Temperature); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if message.DewPoint != nil {
		if err2 := ValidateTemperature(message.DewPoint); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if message.Wind != nil {
		if err2 := ValidateWind(message.Wind); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if message.WeatherType != "" {
		if !(message.WeatherType == "Sunny" || message.WeatherType == "Cloudy" || message.WeatherType == "Raining" || message.WeatherType == "Windy") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.weatherType", message.WeatherType, []interface{}{"Sunny", "Cloudy", "Raining", "Windy"}))
		}
	}
	if message.WeatherTime != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.weatherTime", message.WeatherTime, goa.FormatDateTime))
	}
	return
}

// ValidateTemperature runs the validations defined on Temperature.
func ValidateTemperature(message *logpb.Temperature) (err error) {
	if message.Unit != "" {
		if !(message.Unit == "K" || message.Unit == "C" || message.Unit == "F") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.unit", message.Unit, []interface{}{"K", "C", "F"}))
		}
	}
	return
}

// ValidateWind runs the validations defined on Wind.
func ValidateWind(message *logpb.Wind) (err error) {
	if message.Direction != "" {
		if !(message.Direction == "S" || message.Direction == "SE" || message.Direction == "E" || message.Direction == "NE" || message.Direction == "N" || message.Direction == "NW" || message.Direction == "W" || message.Direction == "SW") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.direction", message.Direction, []interface{}{"S", "SE", "E", "NE", "N", "NW", "W", "SW"}))
		}
	}
	if message.Unit != "" {
		if !(message.Unit == "KPH" || message.Unit == "MPH") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.unit", message.Unit, []interface{}{"KPH", "MPH"}))
		}
	}
	return
}

// ValidateGetRequest runs the validations defined on GetRequest.
func ValidateGetRequest(message *logpb.GetRequest) (err error) {
	if message.CreatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.createdAt", message.CreatedAt, goa.FormatDateTime))
	}
	if message.UpdatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.updatedAt", message.UpdatedAt, goa.FormatDateTime))
	}
	if message.Size != "" {
		if !(message.Size == "S" || message.Size == "M" || message.Size == "L" || message.Size == "XL") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.size", message.Size, []interface{}{"S", "M", "L", "XL"}))
		}
	}
	if message.AddedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.addedAt", message.AddedAt, goa.FormatDateTime))
	}
	if message.Weather != nil {
		if err2 := ValidateWeather(message.Weather); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateUpdateRequest runs the validations defined on UpdateRequest.
func ValidateUpdateRequest(message *logpb.UpdateRequest) (err error) {
	if message.CreatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.createdAt", message.CreatedAt, goa.FormatDateTime))
	}
	if message.UpdatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.updatedAt", message.UpdatedAt, goa.FormatDateTime))
	}
	if message.Size != "" {
		if !(message.Size == "S" || message.Size == "M" || message.Size == "L" || message.Size == "XL") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.size", message.Size, []interface{}{"S", "M", "L", "XL"}))
		}
	}
	if message.AddedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.addedAt", message.AddedAt, goa.FormatDateTime))
	}
	if message.Weather != nil {
		if err2 := ValidateWeather(message.Weather); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateDeleteRequest runs the validations defined on DeleteRequest.
func ValidateDeleteRequest(message *logpb.DeleteRequest) (err error) {
	if message.CreatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.createdAt", message.CreatedAt, goa.FormatDateTime))
	}
	if message.UpdatedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.updatedAt", message.UpdatedAt, goa.FormatDateTime))
	}
	if message.Size != "" {
		if !(message.Size == "S" || message.Size == "M" || message.Size == "L" || message.Size == "XL") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.size", message.Size, []interface{}{"S", "M", "L", "XL"}))
		}
	}
	if message.AddedAt != "" {
		err = goa.MergeErrors(err, goa.ValidateFormat("message.addedAt", message.AddedAt, goa.FormatDateTime))
	}
	if message.Weather != nil {
		if err2 := ValidateWeather(message.Weather); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateListRequest runs the validations defined on ListRequest.
func ValidateListRequest(message *logpb.ListRequest) (err error) {
	if message.Filters == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("filters", "message"))
	}
	if message.Search == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("search", "message"))
	}
	if message.Sort == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("sort", "message"))
	}
	if message.Pagination == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("pagination", "message"))
	}
	if message.Filters != nil {
		if err2 := ValidateLogFilters(message.Filters); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if message.Sort != nil {
		if err2 := ValidateLogSorts(message.Sort); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateLogFilters runs the validations defined on LogFilters.
func ValidateLogFilters(message *logpb.LogFilters) (err error) {
	for _, e := range message.Name {
		if e != nil {
			if err2 := ValidateStringFilter(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range message.Start {
		if e != nil {
			if err2 := ValidateTimeFilter(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range message.End {
		if e != nil {
			if err2 := ValidateTimeFilter(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateStringFilter runs the validations defined on StringFilter.
func ValidateStringFilter(message *logpb.StringFilter) (err error) {
	if !(message.Operator == "=" || message.Operator == "!=") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operator", message.Operator, []interface{}{"=", "!="}))
	}
	return
}

// ValidateTimeFilter runs the validations defined on TimeFilter.
func ValidateTimeFilter(message *logpb.TimeFilter) (err error) {
	err = goa.MergeErrors(err, goa.ValidateFormat("message.key", message.Key, goa.FormatDateTime))

	if !(message.Operator == "=" || message.Operator == ">" || message.Operator == ">=" || message.Operator == "<=" || message.Operator == "<") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.operator", message.Operator, []interface{}{"=", ">", ">=", "<=", "<"}))
	}
	return
}

// ValidateLogSearch runs the validations defined on LogSearch.
func ValidateLogSearch(message *logpb.LogSearch) (err error) {

	return
}

// ValidateLogSorts runs the validations defined on LogSorts.
func ValidateLogSorts(message *logpb.LogSorts) (err error) {
	if message.Id != "" {
		if !(message.Id == "ASC, DESC") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.id", message.Id, []interface{}{"ASC, DESC"}))
		}
	}
	if message.Start != "" {
		if !(message.Start == "ASC, DESC") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.start", message.Start, []interface{}{"ASC, DESC"}))
		}
	}
	if message.End != "" {
		if !(message.End == "ASC, DESC") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("message.end", message.End, []interface{}{"ASC, DESC"}))
		}
	}
	return
}

// ValidateLogPagination runs the validations defined on LogPagination.
func ValidateLogPagination(message *logpb.LogPagination) (err error) {

	return
}

// protobufLogpbWeatherToLogWeather builds a value of type *log.Weather from a
// value of type *logpb.Weather.
func protobufLogpbWeatherToLogWeather(v *logpb.Weather) *log.Weather {
	if v == nil {
		return nil
	}
	res := &log.Weather{}
	if v.Id != 0 {
		idptr := int(v.Id)
		res.ID = &idptr
	}
	if v.CreatedAt != "" {
		res.CreatedAt = &v.CreatedAt
	}
	if v.FireId != 0 {
		fireIDptr := int(v.FireId)
		res.FireID = &fireIDptr
	}
	if v.LogId != 0 {
		logIDptr := int(v.LogId)
		res.LogID = &logIDptr
	}
	if v.Humidity != 0 {
		res.Humidity = &v.Humidity
	}
	if v.WeatherType != "" {
		res.WeatherType = &v.WeatherType
	}
	if v.WeatherTime != "" {
		res.WeatherTime = &v.WeatherTime
	}
	if v.Temperature != nil {
		res.Temperature = protobufLogpbTemperatureToLogTemperature(v.Temperature)
	}
	if v.DewPoint != nil {
		res.DewPoint = protobufLogpbTemperatureToLogTemperature(v.DewPoint)
	}
	if v.Wind != nil {
		res.Wind = protobufLogpbWindToLogWind(v.Wind)
	}

	return res
}

// protobufLogpbTemperatureToLogTemperature builds a value of type
// *log.Temperature from a value of type *logpb.Temperature.
func protobufLogpbTemperatureToLogTemperature(v *logpb.Temperature) *log.Temperature {
	if v == nil {
		return nil
	}
	res := &log.Temperature{}
	if v.Unit != "" {
		res.Unit = &v.Unit
	}
	if v.Value != 0 {
		res.Value = &v.Value
	}

	return res
}

// protobufLogpbWindToLogWind builds a value of type *log.Wind from a value of
// type *logpb.Wind.
func protobufLogpbWindToLogWind(v *logpb.Wind) *log.Wind {
	if v == nil {
		return nil
	}
	res := &log.Wind{}
	if v.Speed != 0 {
		res.Speed = &v.Speed
	}
	if v.Direction != "" {
		res.Direction = &v.Direction
	}
	if v.Unit != "" {
		res.Unit = &v.Unit
	}

	return res
}

// svcLogWeatherToLogpbWeather builds a value of type *logpb.Weather from a
// value of type *log.Weather.
func svcLogWeatherToLogpbWeather(v *log.Weather) *logpb.Weather {
	if v == nil {
		return nil
	}
	res := &logpb.Weather{}
	if v.ID != nil {
		res.Id = int32(*v.ID)
	}
	if v.CreatedAt != nil {
		res.CreatedAt = *v.CreatedAt
	}
	if v.FireID != nil {
		res.FireId = int32(*v.FireID)
	}
	if v.LogID != nil {
		res.LogId = int32(*v.LogID)
	}
	if v.Humidity != nil {
		res.Humidity = *v.Humidity
	}
	if v.WeatherType != nil {
		res.WeatherType = *v.WeatherType
	}
	if v.WeatherTime != nil {
		res.WeatherTime = *v.WeatherTime
	}
	if v.Temperature != nil {
		res.Temperature = svcLogTemperatureToLogpbTemperature(v.Temperature)
	}
	if v.DewPoint != nil {
		res.DewPoint = svcLogTemperatureToLogpbTemperature(v.DewPoint)
	}
	if v.Wind != nil {
		res.Wind = svcLogWindToLogpbWind(v.Wind)
	}

	return res
}

// svcLogTemperatureToLogpbTemperature builds a value of type
// *logpb.Temperature from a value of type *log.Temperature.
func svcLogTemperatureToLogpbTemperature(v *log.Temperature) *logpb.Temperature {
	if v == nil {
		return nil
	}
	res := &logpb.Temperature{}
	if v.Unit != nil {
		res.Unit = *v.Unit
	}
	if v.Value != nil {
		res.Value = *v.Value
	}

	return res
}

// svcLogWindToLogpbWind builds a value of type *logpb.Wind from a value of
// type *log.Wind.
func svcLogWindToLogpbWind(v *log.Wind) *logpb.Wind {
	if v == nil {
		return nil
	}
	res := &logpb.Wind{}
	if v.Speed != nil {
		res.Speed = *v.Speed
	}
	if v.Direction != nil {
		res.Direction = *v.Direction
	}
	if v.Unit != nil {
		res.Unit = *v.Unit
	}

	return res
}

// protobufLogpbLogFiltersToLogLogFilters builds a value of type
// *log.LogFilters from a value of type *logpb.LogFilters.
func protobufLogpbLogFiltersToLogLogFilters(v *logpb.LogFilters) *log.LogFilters {
	res := &log.LogFilters{}
	if v.Name != nil {
		res.Name = make([]*log.StringFilter, len(v.Name))
		for i, val := range v.Name {
			res.Name[i] = &log.StringFilter{
				Key:      val.Key,
				Operator: val.Operator,
				Value:    val.Value,
			}
		}
	}
	if v.Start != nil {
		res.Start = make([]*log.TimeFilter, len(v.Start))
		for i, val := range v.Start {
			res.Start[i] = &log.TimeFilter{
				Key:      val.Key,
				Operator: val.Operator,
				Value:    int(val.Value),
			}
		}
	}
	if v.End != nil {
		res.End = make([]*log.TimeFilter, len(v.End))
		for i, val := range v.End {
			res.End[i] = &log.TimeFilter{
				Key:      val.Key,
				Operator: val.Operator,
				Value:    int(val.Value),
			}
		}
	}

	return res
}

// protobufLogpbLogSearchToLogLogSearch builds a value of type *log.LogSearch
// from a value of type *logpb.LogSearch.
func protobufLogpbLogSearchToLogLogSearch(v *logpb.LogSearch) *log.LogSearch {
	res := &log.LogSearch{}
	if v.Name != "" {
		res.Name = &v.Name
	}
	if v.Description != "" {
		res.Description = &v.Description
	}

	return res
}

// protobufLogpbLogSortsToLogLogSorts builds a value of type *log.LogSorts from
// a value of type *logpb.LogSorts.
func protobufLogpbLogSortsToLogLogSorts(v *logpb.LogSorts) *log.LogSorts {
	res := &log.LogSorts{}
	if v.Id != "" {
		res.ID = &v.Id
	}
	if v.Start != "" {
		res.Start = &v.Start
	}
	if v.End != "" {
		res.End = &v.End
	}

	return res
}

// protobufLogpbLogPaginationToLogLogPagination builds a value of type
// *log.LogPagination from a value of type *logpb.LogPagination.
func protobufLogpbLogPaginationToLogLogPagination(v *logpb.LogPagination) *log.LogPagination {
	res := &log.LogPagination{
		Page:  int(v.Page),
		Limit: int(v.Limit),
	}

	return res
}

// svcLogLogFiltersToLogpbLogFilters builds a value of type *logpb.LogFilters
// from a value of type *log.LogFilters.
func svcLogLogFiltersToLogpbLogFilters(v *log.LogFilters) *logpb.LogFilters {
	res := &logpb.LogFilters{}
	if v.Name != nil {
		res.Name = make([]*logpb.StringFilter, len(v.Name))
		for i, val := range v.Name {
			res.Name[i] = &logpb.StringFilter{
				Key:      val.Key,
				Operator: val.Operator,
				Value:    val.Value,
			}
		}
	}
	if v.Start != nil {
		res.Start = make([]*logpb.TimeFilter, len(v.Start))
		for i, val := range v.Start {
			res.Start[i] = &logpb.TimeFilter{
				Key:      val.Key,
				Operator: val.Operator,
				Value:    int32(val.Value),
			}
		}
	}
	if v.End != nil {
		res.End = make([]*logpb.TimeFilter, len(v.End))
		for i, val := range v.End {
			res.End[i] = &logpb.TimeFilter{
				Key:      val.Key,
				Operator: val.Operator,
				Value:    int32(val.Value),
			}
		}
	}

	return res
}

// svcLogLogSearchToLogpbLogSearch builds a value of type *logpb.LogSearch from
// a value of type *log.LogSearch.
func svcLogLogSearchToLogpbLogSearch(v *log.LogSearch) *logpb.LogSearch {
	res := &logpb.LogSearch{}
	if v.Name != nil {
		res.Name = *v.Name
	}
	if v.Description != nil {
		res.Description = *v.Description
	}

	return res
}

// svcLogLogSortsToLogpbLogSorts builds a value of type *logpb.LogSorts from a
// value of type *log.LogSorts.
func svcLogLogSortsToLogpbLogSorts(v *log.LogSorts) *logpb.LogSorts {
	res := &logpb.LogSorts{}
	if v.ID != nil {
		res.Id = *v.ID
	}
	if v.Start != nil {
		res.Start = *v.Start
	}
	if v.End != nil {
		res.End = *v.End
	}

	return res
}

// svcLogLogPaginationToLogpbLogPagination builds a value of type
// *logpb.LogPagination from a value of type *log.LogPagination.
func svcLogLogPaginationToLogpbLogPagination(v *log.LogPagination) *logpb.LogPagination {
	res := &logpb.LogPagination{
		Page:  int32(v.Page),
		Limit: int32(v.Limit),
	}

	return res
}

// svcLogPaginationToLogpbPagination builds a value of type *logpb.Pagination
// from a value of type *log.Pagination.
func svcLogPaginationToLogpbPagination(v *log.Pagination) *logpb.Pagination {
	if v == nil {
		return nil
	}
	res := &logpb.Pagination{}
	if v.Total != nil {
		res.Total = int32(*v.Total)
	}
	if v.Page != nil {
		res.Page = int32(*v.Page)
	}
	if v.Limit != nil {
		res.Limit = int32(*v.Limit)
	}

	return res
}

// protobufLogpbPaginationToLogPagination builds a value of type
// *log.Pagination from a value of type *logpb.Pagination.
func protobufLogpbPaginationToLogPagination(v *logpb.Pagination) *log.Pagination {
	if v == nil {
		return nil
	}
	res := &log.Pagination{}
	if v.Total != 0 {
		totalptr := int(v.Total)
		res.Total = &totalptr
	}
	if v.Page != 0 {
		pageptr := int(v.Page)
		res.Page = &pageptr
	}
	if v.Limit != 0 {
		limitptr := int(v.Limit)
		res.Limit = &limitptr
	}

	return res
}
